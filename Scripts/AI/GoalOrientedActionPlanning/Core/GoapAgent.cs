using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

// Represents a GOAP Agent. GOAP Agent implementations
// have to derive this class to use the functions of
// the GOAP System.
public abstract class GoapAgent : MonoBehaviour
{

    // Stores the id of the GOAP Agent
    public int characterId;
    // Stores the next id of the GOAP Agents
    private static int nextId = 0;
    // Stores the list of the GOAP Actions which
    // can be used by the GOAP Agent.
    public List<GoapAction> actions = new List<GoapAction>();
    // Stores the current action.
    public GoapAction currentAction;
    // Handles the navigation component.
    public NavMeshAgent navMeshAgent;
    // Stores the current GOAP Goal.
    protected GoapGoal currentGoal;
    // Every GOAP Agent needs a GOAP Planner
    // which makes plans for the GOAP Agent.
    GoapPlanner planner;
    // Stores the GOAP Actions sequence that
    // generated by the GOAP Planner.
    Queue<GoapAction> actionQueue;

    // Start is called before the first frame update
    public void Start()
    {
        navMeshAgent = this.GetComponent<NavMeshAgent>();
        characterId = nextId++;
    }

    //LateUpdate is called every frame, if the Behaviour is enabled.
    //LateUpdate is called after all Update functions have been called.
    public void LateUpdate()
    {
        if (HasRunningAction())
        {
            ExecuteCurrentAction();
            return;
        }

        if (ReadyToPlan() && HasGoal())
        {
            planner = new GoapPlanner(actions, this);
            actionQueue = planner.Plan(currentGoal);
        }

        // Ha az akciók listája üres
        if (PlanHasBeenExecuted())
        {
            currentGoal = null;
            planner = null;
        }

        // Ha van tervünk, és még van hátralévõ akció a sorban.
        if (IsPlanRunning())
        {
            currentAction = actionQueue.Dequeue();
            Debug.Log("GOAP Agent Id = " + this.characterId + " has next action: " + currentAction.nameOfTheAction);
            currentAction.BeforeAction();

            if (currentAction.position != null)
            {
                currentAction.running = true;
                currentAction.owner.navMeshAgent.SetDestination(currentAction.position.transform.position);
            }
            else
            {
                actionQueue = null;
            }
        }
    }

    // Checks whether the GOAP Agent is executing an action.
    private bool HasRunningAction()
    {
        if (currentAction != null && currentAction.running)
        {
            return true;
        }
        return false;
    }

    // Checks whether the GOAP Agent is ready to make a
    // new plan.
    private bool ReadyToPlan()
    {
        if (planner == null || actionQueue == null)
        {
            return true;
        }
        return false;
    }

    // Checks the goal.
    private bool HasGoal()
    {
        if (currentGoal != null)
        {
            return true;
        }
        return false;
    }

    // Checks whether the plan has been executed.
    private bool PlanHasBeenExecuted()
    {
        if (actionQueue != null && actionQueue.Count == 0)
        {
            return true;
        }
        return false;
    }

    // Returns true if the plan is still in running state.
    private bool IsPlanRunning()
    {
        if (actionQueue != null && actionQueue.Count > 0)
        {
            return true;
        }
        return false;
    }

    // Executes the GOAP Agent's current action.
    private void ExecuteCurrentAction()
    {
        // Ha az ágens éppen mozog valahova és kellõnen közel kerül célhoz
        if (currentAction.owner.navMeshAgent.hasPath && currentAction.owner.navMeshAgent.remainingDistance < 1)
        {
            currentAction.ExecuteAction();
            CloseCurrentAction();
        }
    }

    // Closes the current action with the proper
    // method call.
    private void CloseCurrentAction()
    {
        currentAction.AfterAction();
        currentAction.running = false;
    }

    // It will initialize the list of the usable
    // actions.
    public abstract void InitializeActions();

    // Generates the GOAP Agent relevant world
    // states for the GOAP Planner.
    public abstract Dictionary<Conditions, bool> GenerateAgentRelevantStates();

}
